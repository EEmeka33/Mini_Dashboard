/* main.c
 * LVGL 9.3 + SDL2 swipeable image widget example.
 *
 * Put image1.c next to this file (generated by LVGL imageconverter).
 * Add image2.c, image3.c,... and uncomment them in imgs[] if you want multiple images.
 */

#define SDL_MAIN_HANDLED
#include <stdio.h>
#include <stdbool.h>
#include <SDL2/SDL.h>

#include "lvgl.h"
#include "drivers/sdl/lv_sdl_mousewheel.h" /* optional */
#include "drivers/sdl/lv_sdl_keyboard.h"   /* optional */

#include "image1.c" /* generated file - must define lv_image_dsc_t image1 */
LV_IMG_DECLARE(image1);
#include "image2.c"
LV_IMG_DECLARE(image2);

/* Example: if you generate more images, include them too and uncomment below:
   #include "image2.c"
   LV_IMG_DECLARE(image2);
   #include "image3.c"
   LV_IMG_DECLARE(image3);
*/

#ifndef SDL_HOR_RES
#define SDL_HOR_RES 800
#endif
#ifndef SDL_VER_RES
#define SDL_VER_RES 480
#endif

/* ---------- pointer read like your example ---------- */
static void pointer_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
{
    (void)indev;
    int mx = 0, my = 0;
    uint32_t buttons = SDL_GetMouseState(&mx, &my);
    data->point.x = mx;
    data->point.y = my;
    data->state = (buttons & SDL_BUTTON(SDL_BUTTON_LEFT)) ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
    data->continue_reading = false;
}

/* ---------- Globals for the carousel ---------- */
static lv_obj_t * img_obj = NULL;
static lv_coord_t center_x = 0;     /* x coordinate where the image should be centered */
static lv_coord_t center_y = 0;
static int start_x = 0;             /* pointer down x */
static int cur_index = 0;           /* current image index */

static lv_image_dsc_t * imgs[] = {
    &image1,
    &image2 /*, &image3, */
};
static const int imgs_count = sizeof(imgs) / sizeof(imgs[0]);

/* animation state */
static int pending_index = -1;      /* index we'll switch to after first phase animation */
static int anim_direction = 0;      /* -1 = left (next), +1 = right (prev) */

/* simple helper to start an X-position animation on an object */
static void animate_obj_x(lv_obj_t * obj, lv_coord_t from, lv_coord_t to, uint32_t time,
                          lv_anim_ready_cb_t ready_cb)
{
    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, obj);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
    lv_anim_set_values(&a, from, to);
    lv_anim_set_time(&a, time);
    lv_anim_set_ready_cb(&a, ready_cb);
    lv_anim_start(&a);
}

/* ready callback for the first-phase animation (move current image off-screen) */
static void first_phase_done(lv_anim_t * a)
{
    (void)a;
    if (pending_index < 0 || pending_index >= imgs_count) {
        /* nothing to do */
        anim_direction = 0;
        pending_index = -1;
        return;
    }

    /* change image to pending one */
    cur_index = pending_index;
    lv_img_set_src(img_obj, imgs[cur_index]);

    /* place new image off-screen on the opposite side of the previous movement,
       then animate it into center */
    lv_coord_t screen_w = lv_obj_get_width(lv_img_get_src(img_obj) ? lv_obj_get_parent(img_obj) : img_obj); /* not used; just keep */
    (void)screen_w;

    /* If we moved previous to left (anim_direction == -1), bring new from right */
    lv_coord_t from_x = center_x + (anim_direction == -1 ? SDL_HOR_RES : -SDL_HOR_RES);
    lv_obj_set_x(img_obj, from_x);
    /* animate to center */
    animate_obj_x(img_obj, from_x, center_x, 200, NULL);

    /* reset anim state */
    anim_direction = 0;
    pending_index = -1;
}

/* Snap back to center */
static void snap_back_done(lv_anim_t * a) { (void)a; /* nothing needed */ }

/* ---------- event callback for the image (press/drag/release) ---------- */
static void img_event_cb(lv_event_t * e)
{
    lv_event_code_t code = lv_event_get_code(e);

    if (code == LV_EVENT_PRESSED) {
        /* record pointer start X */
        lv_indev_t * indev = lv_indev_get_act();
        if (indev) {
            lv_point_t p;
            lv_indev_get_point(indev, &p);
            start_x = p.x;
        } else {
            start_x = 0;
        }
    }
    else if (code == LV_EVENT_PRESSING) {
        /* dragging: move the image horizontally by the drag delta */
        lv_indev_t * indev = lv_indev_get_act();
        if (!indev) return;
        lv_point_t p;
        lv_indev_get_point(indev, &p);
        int dx = p.x - start_x;
        lv_obj_set_x(img_obj, center_x + dx);
    }
    else if (code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST) {
        /* on release decide: next / prev / snap back */
        lv_indev_t * indev = lv_indev_get_act();
        if (!indev) return;
        lv_point_t p;
        lv_indev_get_point(indev, &p);
        int dx = p.x - start_x;

        /* threshold to change image: quarter of image width or 80px minimum */
        lv_coord_t img_w = imgs[cur_index]->header.w;
        int threshold = (int)(img_w / 4);
        if (threshold < 80) threshold = 80;

        if (dx < -threshold && imgs_count > 1) {
            /* swipe left -> next image */
            pending_index = (cur_index + 1) % imgs_count;
            anim_direction = -1;
            /* animate current image off to left, then first_phase_done will swap image and bring new in */
            lv_coord_t cur_x = lv_obj_get_x(img_obj);
            lv_coord_t to_x = center_x - SDL_HOR_RES; /* move left off-screen */
            animate_obj_x(img_obj, cur_x, to_x, 200, first_phase_done);
        }
        else if (dx > threshold && imgs_count > 1) {
            /* swipe right -> previous image */
            pending_index = (cur_index - 1 + imgs_count) % imgs_count;
            anim_direction = +1;
            lv_coord_t cur_x = lv_obj_get_x(img_obj);
            lv_coord_t to_x = center_x + SDL_HOR_RES; /* move right off-screen */
            animate_obj_x(img_obj, cur_x, to_x, 200, first_phase_done);
        }
        else {
            /* not enough swipe: snap back to center */
            lv_coord_t cur_x = lv_obj_get_x(img_obj);
            animate_obj_x(img_obj, cur_x, center_x, 150, snap_back_done);
        }
    }
}

/* ---------- utility: center image on start and register event cb ---------- */
static void setup_image_carousel(lv_obj_t * parent)
{
    /* create image object and set source to first image */
    img_obj = lv_img_create(parent);
    lv_img_set_src(img_obj, imgs[cur_index]);

    /* center coordinates (x,y) for the image top-left to place image centered on screen */
    lv_coord_t scr_w = (lv_coord_t)SDL_HOR_RES;
    lv_coord_t scr_h = (lv_coord_t)SDL_VER_RES;
    lv_coord_t img_w = imgs[cur_index]->header.w;
    lv_coord_t img_h = imgs[cur_index]->header.h;
    center_x = (scr_w - img_w) / 2;
    center_y = (scr_h - img_h) / 2;

    lv_obj_set_pos(img_obj, center_x, center_y);

    /* enable drag capture so pressing/pressing/released events occur on the object */
    lv_obj_add_flag(img_obj, LV_OBJ_FLAG_CLICKABLE);

    /* register event callback to handle press/drag/release */
    lv_obj_add_event_cb(img_obj, img_event_cb, LV_EVENT_ALL, NULL);
}

/* ---------- main ---------- */
int main(void)
{
    /* 1) Init SDL */
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_EVENTS) != 0) {
        fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
        return 1;
    }

    /* 2) Init LVGL */
    lv_init();

#ifndef WIN32
    setenv("DBUS_FATAL_WARNINGS", "0", 1);
#endif

    /* 3) Create LVGL display + SDL window using the LVGL SDL helper */
    lv_display_t * disp = lv_sdl_window_create(SDL_HOR_RES, SDL_VER_RES);
    if (!disp) {
        fprintf(stderr, "lv_sdl_window_create failed\n");
        SDL_Quit();
        return 1;
    }

    /* 4) Optional: create other SDL-based input devices */
    (void)lv_sdl_mousewheel_create();
    (void)lv_sdl_keyboard_create();

    /* 5) Create a custom LVGL pointer input device that reads SDL_GetMouseState directly */
    lv_indev_t * my_mouse = lv_indev_create();
    if (my_mouse) {
        lv_indev_set_type(my_mouse, LV_INDEV_TYPE_POINTER);
        lv_indev_set_read_cb(my_mouse, pointer_read_cb);
    }

    SDL_ShowCursor(SDL_ENABLE);

    /* 6) Build UI: set up carousel on the active screen */
    lv_obj_t * scr = lv_scr_act();
    setup_image_carousel(scr);

    /* 7) Main loop: tick + handler */
    Uint32 lastTick = SDL_GetTicks();
    bool running = true;
    while (running) {
        SDL_Event e;
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) running = false;
        }

        Uint32 now = SDL_GetTicks();
        uint32_t diff = now - lastTick;
        if (diff) {
            lv_tick_inc(diff);
            lastTick = now;
        }

        lv_timer_handler();
        SDL_Delay(1);
    }

    SDL_Quit();
    return 0;
}
